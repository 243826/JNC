submodule foo-cae-threeGpp {
    belongs-to foo-cae {
        prefix foo-cae;
    }

    import ietf-inet-types {
        prefix inet;
    }

    import tailf-common {
        prefix tailf;
    }

    import foo-system {
        prefix foo-system;
    }

    include foo-cae-types;
    include foo-cae-atm;

    // add new revision statements here

    revision 2011-01-06 {
        description "Conversion from confspec.";
    }


    container threeGpp {
        container genprofile {
            leaf pointcodeIdleTimerVal {
                type ranapStaleType;
                default 3;
                tailf:info "minute";
            }
            leaf sccpStaleConnTimerVal {
                type ranapStaleType;
                default 10;
                tailf:info "minute";
            }
            leaf sccpConnLifeVal {
                type ranapStaleType;
                default 120;
                tailf:info "minute";
            }
            leaf pcapMode {
                type foo-system:enableDisableType;
                default disable;
                tailf:info "if enable will read pcap file";
            }
            leaf dynamicPathLearning {
                type foo-system:enableDisableType;
                default enable;
                tailf:info "if path will be learned from packets";
            }
        }

        /*  default scalars  */
        container defaults {
            leaf sectorCongestionThresh {
                type uint8;
                default 60;
                tailf:info "% of nominal sector bandwidth";
            }
            leaf nodeBCongestionThresh {
                type uint8;
                default 60;
                tailf:info "% of nominal nodeB bandwidth";
            }
            leaf backhaulCongestionThresh {
                type uint8;
                default 60;
                tailf:info "% of nominal backhaul bandwidth";
            }
        }


        list sgsn {
            key name;
            unique pointCode;

            leaf name {
                type foo-system:nameType;
            }

            leaf pointCode {
                type uint32;
                mandatory true;

                must  "(count(../../rnc[pointCode=current()/.]) + "
                    + " count(../../stp[pointCode=current()/.])) = 0" {
                    tailf:dependency '.';
                    tailf:dependency '../../rnc';
                    tailf:dependency '../../stp';
                    error-message "pointCode in use";
                }
            }

            container bearerStats {
                config false;
                tailf:cdb-oper;

                leaf rxPkts {
                    type uint64;
                }
                leaf txPkts {
                    type uint64;
                }
                leaf txCdsPkts {
                    type uint64;
                }
                leaf bypassedPkts {
                    type uint64;
                }
                leaf discardedPkts {
                    type uint64;
                }
            }
        }

        list rnc {
            key name;

            leaf name {
                type foo-system:nameType;
            }
            leaf pointCode {
                type uint32;
                mandatory true;

                must  "(count(../../sgsn[pointCode=current()/.]) +"
                    + " count(../../stp[pointCode=current()/.])) = 0" {
                    tailf:dependency '.';
                    tailf:dependency '../../sgsn';
                    tailf:dependency '../../stp';
                    error-message "pointCode in use";
                }
            }

            container bearerStats {
                config false;
                tailf:cdb-oper;

                leaf rxPkts {
                    type uint64;
                }
                leaf txPkts {
                    type uint64;
                }
                leaf txCdsPkts {
                    type uint64;
                }
                leaf bypassedPkts {
                    type uint64;
                }
                leaf discardedPkts {
                    type uint64;
                }
            }
        }

        list backhaul {
            key name;

            leaf name {
                type foo-system:nameType;
            }
            leaf nominalBwKbps {
                type uint32;
                mandatory true;
            }
            leaf congestionThresh {
                type uint8;
                tailf:info "optional attribute used to override /threeGpp/defaults/backhaulCongestionThresh";
            }
            leaf rnc {
                type leafref {
                    path "../../rnc/name";
                }
                mandatory true;
            }

            container status {
                config false;
                tailf:cdb-oper;

                leaf congested {
                    type boolean;
                }
                leaf configurationError {
                    type boolean;
                }
                leaf utilization {
                    type uint8;
                }
            }
        }

        list nodeB {
            key name;

            leaf name {
                type foo-system:nameType;
            }
            leaf nominalBwKbps {
                type uint32;
                mandatory true;
            }
            leaf latitude {
                type latitudeType;
                default 0;
            }
            leaf longitude {
                type longitudeType;
                default 0;
            }
            leaf congestionThresh {
                type uint8;
                tailf:info "optional attribute used to override /threeGpp/defaults/nodeBCongestionThresh";
            }
            leaf backhaul {
                type leafref {
                    path "../../backhaul/name";
                }
                mandatory true;
            }

            container status {
                config false;
                tailf:cdb-oper;

                leaf congested {
                    type boolean;
                }
                leaf configurationError {
                    type boolean;
                }
                leaf utilization {
                    type uint8;
                }
            }
        }

        list sector {
            key "nodeB id";
            unique "lai sai";

            leaf nodeB {
                type leafref {
                    path "../../nodeB/name";
                }
            }
            leaf id {
                type uint8;
            }
            leaf lai {
                type uint16;
                mandatory true;
            }
            leaf sai {
                type uint16;
                mandatory true;
            }
            leaf nominalBwKbps {
                type uint32;
                mandatory true;
            }
            leaf congestionThresh {
                type uint8;
                tailf:info "optional attribute used to override /threeGpp/defaults/sectorCongestionThresh";
            }

            container status {
                config false;
                tailf:cdb-oper;

                leaf congested {
                    type boolean;
                }
                leaf configurationError {
                    type boolean;
                }
                leaf utilization {
                    type uint8;
                }
            }
        }

        container sctp {
            container profile {
                leaf validCookieLife {
                    type validCookieLifeType;
                    default 60000;
                    tailf:info "ms";
                }
                leaf assocMaxRetrans {
                    type assocMaxRetransType;
                    default 5;
                }
                leaf pathMaxRetrans {
                    type pathMaxRetransType;
                    default 3;
                }
                leaf maxInitRetrans {
                    type maxInitRetransType;
                    default 8;
                }
                leaf maxInitPathRetrans {
                    type maxInitPathRetransType;
                    default 2;
                }
                leaf bundling {
                    type foo-system:enableDisableType;
                    default enable;
                }
                leaf bundlingTime {
                    type bundlingTimeType;
                    default 100;
                    tailf:info "ms";
                }
                leaf sackPeriod {
                    type sackPeriodType;
                    default 200;
                    tailf:info "ms";
                }
                leaf sackFrequency {
                    type sackFrequencyType;
                    default 2;
                }
                leaf rtoInit {
                    type rtoInitType;
                    default 10;
                    tailf:info "ms";
                }
                leaf rtoMin {
                    type rtoMinType;
                    default 10;
                    tailf:info "ms";
                }
                leaf rtoMax {
                    type rtoMaxType;
                    default 200;
                    tailf:info "ms";
                }
                leaf mtu {
                    type foo-system:mtuType;
                    default 1500;
                }
                leaf heartBeatInterval {
                    type sctpHBIntervalType;
                    default 30;
                    tailf:info "s";
                }
            }

            list endpoint {
                key "ipAddr port";

                leaf ipAddr {
                    type foo-system:wildCardIPv4;
                }
                leaf port {
                    type foo-system:wildCardPort;
                }

                /*  disallow port=* && ipAddr=* */
                must "((current()/ipAddr != '*') or (current()/port = '*'))" {
                    tailf:dependency '.';
                    error-message "wildcard ipAddr and specific port disallowed";
                }

                /*  disallow ipAddr/* and ipAddr/<port> simultaneously  */
                must  "((count(/threeGpp/sctp/endpoint[ipAddr = current()/ipAddr][port = '*']) = 0) or"
                    + " (count(/threeGpp/sctp/endpoint[ipAddr = current()/ipAddr][port != '*']) = 0))" {
                    tailf:dependency '.';
                    error-message "same ipAddr may not have * and non-* endpoints";
                }
            }

            list rnc {
                key ipAddr;

                leaf ipAddr {
                    type foo-system:wildCardIPv4;
                }
            }

            list sgsn {
                key ipAddr;

                leaf ipAddr {
                    type foo-system:wildCardIPv4;
                }
            }

            list pathStatus {
                config false;
                tailf:cdb-oper;
                key pathname;

                leaf pathname {
                    type string;
                }
                leaf active {
                    type boolean;
                }
            }

            container sctpGenStats {
                config false;
                tailf:cdb-oper;

                leaf rxSouthPktsBypassed {
                    type uint64;
                }
                leaf rxSouthPktsDiscarded {
                    type uint64;
                }
                leaf rxSouthPktsProcessed {
                    type uint64;
                }
                leaf rxNorthPktsBypassed {
                    type uint64;
                }
                leaf rxNorthPktsDiscarded {
                    type uint64;
                }
                leaf rxNorthPktsProcessed {
                    type uint64;
                }
            }

            list tuple {
                key id;
                config false;
                tailf:cdb-oper;

                leaf id {
                    type uint32;
                }
                leaf srcIpAddr {
                    type inet:ipv4-address;
                }
                leaf srcPort {
                    type inet:port-number;
                }
                leaf dstIpAddr {
                    type inet:ipv4-address;
                }
                leaf dstPort {
                    type inet:port-number;
                }
                leaf dstVTag {
                    type uint32;
                }
                leaf direction {
                    type SctpDirectionType;
                }

                container sctpStats {
                    uses sctpCounters;
                    tailf:cdb-oper;
                }
            }
        }

        container sscop {
            container sscopGenStats {
                config false;
                tailf:cdb-oper;

                leaf rxSouthPktsBypassed {
                    type uint64;
                }
                leaf rxSouthPktsDiscarded {
                    type uint64;
                }
                leaf rxSouthPktsProcessed {
                    type uint64;
                }
                leaf rxNorthPktsBypassed {
                    type uint64;
                }
                leaf rxNorthPktsDiscarded {
                    type uint64;
                }
                leaf rxNorthPktsProcessed {
                    type uint64;
                }
            }

            list pathStatus {
                key pathname;
                config false;
                tailf:cdb-oper;

                leaf pathname {
                    type string;
                }
                leaf alive {
                    type boolean;
                }
            }
        }

        list stp {
            key name;

            leaf name {
                type foo-system:nameType;
            }
            leaf pointCode {
                type uint32;
                mandatory true;

                must  "(count(../../rnc[pointCode=current()/.]) +"
                    + "count(../../sgsn[pointCode=current()/.])) = 0" {
                    tailf:dependency '.';
                    tailf:dependency '../../rnc';
                    tailf:dependency '../../sgsn';
                    error-message "pointCode in use";
                }
            }
        }

        list path {
            config false;
            tailf:cdb-oper;

            container ranap {
                container appStats {
                    uses ranapCounters;
                }

                container msgDropStats {
                    uses ranapMsgDropCounters;
                }

                list rncStats {
                    key pathname;

                    leaf pathname {
                        type string;
                    }
                    uses ranapTransmitterCounters;
                }

                list cnStats {
                    key pathname;

                    leaf pathname {
                        type string;
                    }
                    uses ranapTransmitterCounters;
                }
            }

            list sccp {
                list rncStats {
                    key pathname;

                    leaf pathname {
                        type string;
                    }
                    uses sccpCounters;
                }

                list cnStats {
                    key pathname;

                    leaf pathname {
                        type string;
                    }
                    uses sccpCounters;
                }
            }

            container pdpContexts {
                uses pdpDetails;
            }
        }

        container ranap {
            container profile {
                leaf servicePdpWithoutImsi {
                    type boolean;
                    default false;
                    tailf:hidden debug;
                    tailf:info "When enabled, CAE will service PDP contexts without associated IMSI";
                }
                leaf pdpstaletimer {
                    type ranapStaleType;
                    default 30;
                    tailf:info "minute";
                }
                leaf pdpSessionLife {
                    type ranapStaleType;
                    default 2880;
                    tailf:info "minute";
                }
                leaf loadRateTimerVal {
                    type ranapStaleType;
                    default 10;
                    tailf:info "second";
                }
                leaf implicitSessionPercentage {
                    type uint32;
                    default 0;
                    tailf:hidden debug;
                    tailf:info "When % set , CAE will create implicit PDP contexts from regular PDPs";
                }
                leaf preservePdpOnRncReset {
                    type foo-system:yesNoType;
                    default no;
                }
                leaf preservePdpOnSgsnReset {
                    type foo-system:yesNoType;
                    default no;
                }
                leaf implicitSessionLearning {
                    type foo-system:yesNoType;
                    default no;
                    tailf:info "When enabled , CAE will learn UEIP from datapath for Sessions";
                }
                leaf multithreadSupport {
                    type foo-system:yesNoType;
                    default yes;
                }
            }

            container generalStats {
                uses generalCounters;
                config false;
                tailf:cdb-oper;
            }

            container imeiCache {
                leaf enable {
                    type boolean;
                    default true;
                    tailf:info " Enables/Disable IMEI Cache ";
                }
                leaf purgeTimerInerval {
                    type ranapImeiCachePurgeTimerType;
                    default 10;
                    tailf:info "IMEI cache purge timer, in minutes";
                }
                leaf maxSize {
                    type ranapImeiCacheSizeUpperBoundType;
                    default 1000000;
                    tailf:info "Upper bound of IMEI cache size";
                }
                leaf maxIdleTime {
                    type ranapImeiCacheEntryIdleTimeType;
                    default 2440;
                    tailf:info "Maximum cache time of unused IMEI entries, in minutes";
                }

                container counters {
                    config false;
                    tailf:cdb-oper;

                    leaf add {
                        type uint64;
                    }
                    leaf imeiUpdate {
                        type uint64;
                    }
                    leaf addViaUserAgent {
                        type uint64;
                    }
                    leaf purge {
                        type uint64;
                    }
                    leaf stalePurge {
                        type uint64;
                    }
                    leaf overflowPurge {
                        type uint64;
                    }
                    leaf imeiViaCallFlow {
                        type uint64;
                    }
                    leaf imeiViaCache {
                        type uint64;
                    }
                    leaf imeiViaRAU {
                        type uint64;
                    }
                    leaf imeiViaAttach {
                        type uint64;
                    }
                    leaf imeiUnavailable {
                        type uint64;
                    }
                }
            }
        }
    }
}